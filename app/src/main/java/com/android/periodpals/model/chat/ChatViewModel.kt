package com.android.periodpals.model.chat

import android.util.Log
import androidx.lifecycle.ViewModel
import com.android.periodpals.model.authentication.AuthenticationViewModel
import com.android.periodpals.model.user.User
import com.android.periodpals.services.JwtTokenService
import io.getstream.chat.android.client.ChatClient

private const val TAG = "ChatViewModel"

/**
 * View model for the chat feature.
 *
 * @property chatClient The client used for connecting to the Stream Chat service.
 */
class ChatViewModel(private val chatClient: ChatClient) : ViewModel() {

  /**
   * Connects the user to the Stream Chat service.
   *
   * @param profile The user's profile information.
   * @param authenticationViewModel The ViewModel used for authentication.
   * @param onSuccess Callback function to be called on successful connection.
   * @param onFailure Callback function to be called on connection failure, with the exception as a
   *   parameter.
   */
  fun connectUser(
      profile: User?,
      authenticationViewModel: AuthenticationViewModel,
      onSuccess: () -> Unit = { Log.d(TAG, "User connected successfully.") },
      onFailure: (Exception) -> Unit = { Log.d(TAG, "Failed to connect user: ${it.message}") },
  ) {
    if (profile == null || authenticationViewModel.authUserData.value == null) {
      Log.d(TAG, "Failed to connect user: profile or authentication data is null.")
      onFailure(RuntimeException("Profile or authentication data is null."))
      return
    }

    val uid = authenticationViewModel.authUserData.value!!.uid
    JwtTokenService.generateStreamToken(
        uid = uid,
        onSuccess = {
          val token = it
          val userImage = profile.imageUrl.ifEmpty { "https://bit.ly/2TIt8NR" }
          val user =
              io.getstream.chat.android.models.User(
                  id = uid, name = profile.name, image = userImage)

          chatClient.connectUser(user = user, token = token).execute()
          Log.d(TAG, "User connected successfully.")
          onSuccess()
        },
        onFailure = {
          Log.d(TAG, "Failed to generate token.")
          onFailure(it)
        })
  }

  /**
   * Creates a channel between the current user and a pal.
   *
   * @param myUid The current user's UID.
   * @param palUid The pal's UID.
   * @param myName The current user's name.
   * @param palName The pal's name.
   */
  fun createChannel(myUid: String, palUid: String, myName: String, palName: String): String {
    Log.d(TAG, "Creating channel between $myUid and $palUid.")
    val channelId = generateChannelId(myUid, palUid)
    val channelType = "messaging"
    val channelCid = generateCid(channelType, channelId)

    // Create a unique channel name for the user and pal
    val channelName = generateChannelName(myUid, palUid, myName, palName)

    chatClient
        .createChannel(
            channelType = channelType,
            channelId = channelId,
            memberIds = listOf(myUid, palUid),
            extraData = mapOf("name" to channelName) // Use dynamic name based on users
            )
        .enqueue { result ->
          if (result.isSuccess) {
            Log.d(TAG, "Channel created successfully!")
          } else {
            Log.e(TAG, "Failed to create channel!")
          }
        }
    return channelCid
  }

  /**
   * Generates a unique channel name by combining and sorting the names of the current user and the
   * pal.
   *
   * @param myUid The current user's UID.
   * @param palUid The pal's UID.
   * @param myName The current user's name.
   * @param palName The pal's name.
   * @return A unique channel name generated by concatenating the sorted names with a separator.
   */
  fun generateChannelName(myUid: String, palUid: String, myName: String, palName: String): String {
    return if (myUid == palUid) {
      "Self-Chat"
    } else {
      val sortedNames = listOf(myName, palName).sorted()
      sortedNames.joinToString(separator = " & ")
    }
  }

  /**
   * Generates a unique channel ID by combining and sorting the UIDs of the current user and the
   * pal.
   *
   * @param myUid The current user's UID.
   * @param palUid The pal's UID.
   * @return A unique channel ID generated by concatenating the sorted UIDs without separators or
   *   dashes.
   */
  fun generateChannelId(myUid: String, palUid: String): String {
    val sortedUids = listOf(myUid, palUid).sorted()
    return sortedUids.joinToString(separator = "").replace("-", "")
  }

  /**
   * Generates a channel CID (Channel ID) in the format `channelType:channelId`.
   *
   * @param channelType The type of the channel (e.g., messaging).
   * @param channelId The unique identifier for the channel.
   * @return The generated CID in the format `channelType:channelId`.
   * @throws IllegalArgumentException if `channelType` or `channelId` is empty.
   */
  fun generateCid(channelType: String, channelId: String): String {
    require(channelType.isNotEmpty()) { "channelType must not be empty" }
    require(channelId.isNotEmpty()) { "channelId must not be empty" }
    return listOf(channelType, channelId).joinToString(separator = ":")
  }
}
